# Работа с git

## 1. Проверка наличия установленного git

 В терминале выполнить команду `git version`. Если git установлен, то появится сообщение о его версии.Если нет , то появится ошибка.

## 2.Установка git

Загружаем последнюю версию git  с сайта:

`https://git-scm.com/downloads`

Устанавливаем с настройками по умолчанию.

## 3.Настройки git

При первом использовании git необходимо представиться,т.е в терминале набрать две команды:

`git config --global user.name «Ваше имя англ буквами»`

`git config --global user.email ваша_почта@example.com`

## 4.Создание репозитория

Получить реппозиторий можно двумя способами

1. В терминале переходим к папке в которой хотим создать репозиторий.Выполняем команду `git init`.

2. Клонировать существующий репозиторий Git из любого места.Выполняем команду `git clone <адрес репозитория>`


## 5. Запись изменений в репозиторий 

1. В терминале вводится команда команда:`git status`. Она предназначена для определения какие файлы в каком состоянии находятся. При этом в терминале будет показано,что git не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены.

2. Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add .`

3. Чтобы конкретно узнать что поменялось, а не только какие файлы были изменены — необходимо использовать команду  `git diff`.

4. Чтобы зафиксировать все  изменения, которые происходили с файлом после команды  *git add* -это набрать в терминале команду `git commit -m"Содержание комментария"`.При этом все  изменения, которые происходили с файлом после команды *git add*, а именно: любые файлы, созданные или изменённые, для которых вы не выполнялась команда *git add*, после редактирования — не войдут в этот коммит.

## 6. Просмотр истории коммитов

1. Чтобы посмотреть историю  создания коммитов или историю клонированного репозитория используется команда `git log`.

По умолчанию (без аргументов) эта команда перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху.Для просмотра журнала в укороченной версии используется команда `git log --oneline`.

 2. Для перехода между commit в log (журнале) используется команда `git checkout номер требуемого commit`
 При этом на экране исчезнут данные которые вводились после этого commita.

 3. Для возврата в ветку *мастер* используется команда `git checkout master`. При её выполнении информация на экране возвращается в исходное состояние.

 ## 7.Работа с ветками

 Для добавления в чистовой текст информации, которая не была введена в *git* предусмотрена функция создания новой ветки(черновика).
 Для этого используется команда в терминале `git branch Название новой ветки`.

  Для перехода на новую ветку с веки *master* набираем команду :`git checkout Название ветки на которую надо перейти`.

 После этого вводим информацию и комитим её на новой ветке командами `git add .,git commit -m"коментарий" или git commit -am"коментарий"` .
 
 При этом не забывать проверять статус комитов. Чтобы слить ветки черновик и чистовик, набирается команда `git merge Название новой ветки(черновик)`
 
  Для их слияния предварительно надо перейти в ветку *master*(чистовик).

 Для удаления уже ненужной ветки используется команда `git branch -d Название ненужной ветки`, при этом флаг (d) вводится маленький.Если ввести (D) В эту команду , то тоже произойдет удаление.С (D)применяется команда если надо нам удалить ветку с изменениями которые не нужны нам в итоговой ветке.

 Для того чтобы вывелась вновь созданная ветка в графическом виде после слияния веток вводится команда `git merge --no-ff имя_ветки`.
 
 После слияний веток не надо забывать комитить информацию `git add .,git commit -m"коментарий" или git commit -am"коментарий" `

 Иногда при слиянии веток может выводиться информация о возникновении конфликта, т е в двух разных ветках находится противоположная информация об одном и том же. Git в данном случае выводит информацию для принятия решения оператором.

 Для сохранения отного из двух несохраненных комитов, например при вводе информации по картинкам (сам а информация и информация о картинке) вводится команда `git add -a название файла репозитория`При этом информация о первом записывается в репозиторий , а информация о картинке нет.

 Для вывода гафического изображения веток вводится команда`git log --graph ` или ` git log --graph --oneline`
 Для просмотра перемещения ветки(HEAD)используется команда `git reflog`
 Для выхода из просмотра истории используется клавиша(**Q**)

 ## 8. Работа с текстом

 1. Выделение текста

 В Markdown есть несколько различных способов выделить текст:

 Например можно обрамить слово звездочками (*) или нижним подчёркиванием (_),тогда он будет написан вот так *кусив* или вот так _курсив_

 Также можно выделить текст полужирным. Для этого надо обрамить слово двойными звёздочками (**) или двойным нижним подчёркиванием (__).Тогда тест будет выглядеть  **полужирный** или так __полужирный__ 
 Можно комбинировать разные способы выделения полужирным и курсивом.Например так *__полужирный курсив__* или так _**полужирный курсив**_.

 2. Списки

 Списки бывают нумерованные и не нумерованные.
 
 Если нам нужен нумерованный список, то мы просто пишем каждый элемент со своим номером через строчку (после номера желательно ставить пробел)  так как  если писать на каждой строке, то информация в окне предварительного просмотра будет выводиться на одной строке. При этом  Markdown  сам его красиво формит . Например вот так:
 1. Элемент

 2. Элемент

 или так 

 3. Элемент
 4. Элемент

 Если нам нужны ненумерованные списки, то мы вместо числа номера можем поставить (+) или (*) . Например вот так:

 + Элемент 1 
 + Элемент 2
 + Элемент 3
 * Элемент 4
 * Элемент 5

 ## 9. Работа с изображениями

 Чтобы вставить изображение в текст достаточно написать следующее:`![Коментарий к картинке](название картинки.jpg)`
![Логотип](Git-01.jpg)

При этом на окне предварительного просмотра будет отображаться изображение без введенного в [ текста].
Если же сделать ошибку в названии файла в(название.jpg), то картинка в окне предварительного просмотра отображаться не будет, а будет отображаться [ текст]

Так как в git не принято сохранять большие обьёмы информации и фотографии, поэтому создаётся файл для их игнорирования .
Файл создаётся из панели программы VSC и должен называться только так`.gitignore` . По другому нельзя иначе ничего не получится.
Потом в этот файл вносится файл изображения `название изображения.jpg` или если много файлов надо внести в файл `gitignore` вносится расширение, например : `.jpg или .png`
После чего командой `git add .gitignore` и `git commit -m"Коментарий"`эта папка комитится.
После этого git ,будет игнорировать файлы находящиеся в папке `.gitignore`

  ## 10.Работа с удаленным репозиторием

 1. Чтобы начать работу с удалённым репозиторием нaдо для начала зарегистрироваться на сервисе GitHub.На данном сервисе через строку поиска можно найти различные проекты или репозитории конкретных людей.Клонировать репозитории на локальный компьютер можно только в папки , которые не являются репозиториями.
  Для проверки является ли папка на локальном компьютере репозиторием, через терминал VSC вводится команда `git status` .Она должна показать , что в ней нет репозитория.При создании своего удалённого репозитория в GitHub вверху справа есть вкладка (+).В этой вкладке есть пункт `New repository`-создание нового репозитория.В выпадающем окне даём название новому репоситорию инажимаем кнопку `Create repqsitory`.При этом GitHub предлагает:
  + создать новый репозиторий через терминал и начать с ним работать
  + можно уже существующий репозиторий привязать к удаленному
  + импортировать код из другого репозитория
  При выборе необходимого пункта на GitHub тамже в каждом пункте написаны команды ,которы надо скопировать и ввести в локальном репозитории.

 2. На GitHub через вкладку **CODE** производим копирование ссылки требуемого репозитория.
 3. На своём компьютере в ранее созданной папке (не репозитории) через терминал VSC вводим команду `git clone скопированная ссылка с GitHub`
 4.  На своём компьютере в терминале вводим команду `cd название папки где должен быть склонированный репозиторий`. Данной командой мы меняем директории с GitHub на директорию ранеесозданной папки.Тем самым создаём в папке репозиторий.
 5. Команда `git clone` составная она не только загружает все изменения,но и пытается слить все ветки на локальном компьютере и в удалённом репозитории.
 6. Копировать ссылки с чужого аккаунта можно только после нажатии кнопки **Fork** на чужом аккаунте. После её нажатия выбранный для копирования чужой репозиторий копируется на мой аккаунт. И тогда уже на своём аккаунте я и выполняю пункт 10.2 и ниже по тексту данной инструкции. Это делается для совместной работы с владельцем скопированного аккаунта, чтобы он принял решение по добавлению моих изменений или отказе (анналогия слияния веток репозитория). 
 7. После клонирования репозитория из удаленного репозитория и выполнения команды `cd название папки где должен быть склонированный репозиторий` я создаю в локальном компьютере в папке с клонированным репозиторием новую ветку. Вношу изменения в репозиторий (форкнутый репозиторий или свой удалённый репозиторий) на локальном компьютере,не забываю делать комиты при всех удобных случаях.
 Команда проверки привязки локального и удалённого репозитория `git remote ` или `git remote -v`
 8. После внесения изменений мне необходимо отправить все свои изменения на удалённый репозиторий ( GitHub).Данная операция выполняется набором в терминале VSC локального компьтера `git puch`.Эта команда позволяет отправить локальный репозиторий на мой удалённый репозиторий на GitHub.
 При этом в некоторых случаях будет необходимо подружить мой локальный репозиторий с моим удалённым.В данном случае как это сделать нам подскажет GitHub.

 9. Для того чтобы локальный репозиторий был актуальным с удалённым, из-за того,что я сам внёс какие-то изменения в удалённом репозитории с другого компьютера или при работе в команде был кем-то изменён ранее форкнутый репозиторий используется команда `git pull`. Эта команда позволяет скачать всё из текущего удалённого репозитория и автоматически сделать *merge* (слияние) на локальном компьютере.
